//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by \generate-code.bat.
//
//     Changes to this file will be lost when the code is regenerated.
//     The build server regenerates the code before each build and a pre-build
//     step will regenerate the code on each local build.
//
//     See https://github.com/angularsen/UnitsNet/wiki/Adding-a-New-Unit for how to add or edit units.
//
//     Add CustomCode\Quantities\MyQuantity.extra.cs files to add code to generated quantities.
//     Add UnitDefinitions\MyQuantity.json and run generate-code.bat to generate new units or quantities.
//
// </auto-generated>
//------------------------------------------------------------------------------

// Licensed under MIT No Attribution, see LICENSE file at the root.
// Copyright 2013 Andreas Gullberg Larsen (andreas.larsen84@gmail.com). Maintained at https://github.com/angularsen/UnitsNet.

using System;
using System.Globalization;
using JetBrains.Annotations;
using UnitsNet.InternalHelpers;
using UnitsNet.Units;
using System.Collections.Generic;

#nullable enable

namespace UnitsNet
{
    /// <summary>
    ///     Dynamically parse or construct quantities when types are only known at runtime.
    /// </summary>
    public static partial class Quantity
    {
        /// <summary>
        /// All QuantityInfo instances mapped by quantity name that are present in UnitsNet by default.
        /// </summary>
        public static readonly IDictionary<string, QuantityInfo> ByName = new Dictionary<string, QuantityInfo>
        {
            { "Acceleration", Acceleration.Info },
            { "AmountOfSubstance", AmountOfSubstance.Info },
            { "AmplitudeRatio", AmplitudeRatio.Info },
            { "Angle", Angle.Info },
            { "ApparentEnergy", ApparentEnergy.Info },
            { "ApparentPower", ApparentPower.Info },
            { "Area", Area.Info },
            { "AreaDensity", AreaDensity.Info },
            { "AreaMomentOfInertia", AreaMomentOfInertia.Info },
            { "BitRate", BitRate.Info },
            { "BrakeSpecificFuelConsumption", BrakeSpecificFuelConsumption.Info },
            { "Capacitance", Capacitance.Info },
            { "CoefficientOfThermalExpansion", CoefficientOfThermalExpansion.Info },
            { "Density", Density.Info },
            { "Duration", Duration.Info },
            { "DynamicViscosity", DynamicViscosity.Info },
            { "ElectricAdmittance", ElectricAdmittance.Info },
            { "ElectricCharge", ElectricCharge.Info },
            { "ElectricChargeDensity", ElectricChargeDensity.Info },
            { "ElectricConductance", ElectricConductance.Info },
            { "ElectricConductivity", ElectricConductivity.Info },
            { "ElectricCurrent", ElectricCurrent.Info },
            { "ElectricCurrentDensity", ElectricCurrentDensity.Info },
            { "ElectricCurrentGradient", ElectricCurrentGradient.Info },
            { "ElectricField", ElectricField.Info },
            { "ElectricInductance", ElectricInductance.Info },
            { "ElectricPotential", ElectricPotential.Info },
            { "ElectricPotentialAc", ElectricPotentialAc.Info },
            { "ElectricPotentialChangeRate", ElectricPotentialChangeRate.Info },
            { "ElectricPotentialDc", ElectricPotentialDc.Info },
            { "ElectricResistance", ElectricResistance.Info },
            { "ElectricResistivity", ElectricResistivity.Info },
            { "ElectricSurfaceChargeDensity", ElectricSurfaceChargeDensity.Info },
            { "Energy", Energy.Info },
            { "Entropy", Entropy.Info },
            { "Force", Force.Info },
            { "ForceChangeRate", ForceChangeRate.Info },
            { "ForcePerLength", ForcePerLength.Info },
            { "Frequency", Frequency.Info },
            { "FuelEfficiency", FuelEfficiency.Info },
            { "HeatFlux", HeatFlux.Info },
            { "HeatTransferCoefficient", HeatTransferCoefficient.Info },
            { "Illuminance", Illuminance.Info },
            { "Information", Information.Info },
            { "Irradiance", Irradiance.Info },
            { "Irradiation", Irradiation.Info },
            { "KinematicViscosity", KinematicViscosity.Info },
            { "LapseRate", LapseRate.Info },
            { "Length", Length.Info },
            { "Level", Level.Info },
            { "LinearDensity", LinearDensity.Info },
            { "LinearPowerDensity", LinearPowerDensity.Info },
            { "Luminosity", Luminosity.Info },
            { "LuminousFlux", LuminousFlux.Info },
            { "LuminousIntensity", LuminousIntensity.Info },
            { "MagneticField", MagneticField.Info },
            { "MagneticFlux", MagneticFlux.Info },
            { "Magnetization", Magnetization.Info },
            { "Mass", Mass.Info },
            { "MassConcentration", MassConcentration.Info },
            { "MassFlow", MassFlow.Info },
            { "MassFlux", MassFlux.Info },
            { "MassFraction", MassFraction.Info },
            { "MassMomentOfInertia", MassMomentOfInertia.Info },
            { "MolarEnergy", MolarEnergy.Info },
            { "MolarEntropy", MolarEntropy.Info },
            { "Molarity", Molarity.Info },
            { "MolarMass", MolarMass.Info },
            { "Permeability", Permeability.Info },
            { "Permittivity", Permittivity.Info },
            { "Power", Power.Info },
            { "PowerDensity", PowerDensity.Info },
            { "PowerRatio", PowerRatio.Info },
            { "Pressure", Pressure.Info },
            { "PressureChangeRate", PressureChangeRate.Info },
            { "Ratio", Ratio.Info },
            { "RatioChangeRate", RatioChangeRate.Info },
            { "ReactiveEnergy", ReactiveEnergy.Info },
            { "ReactivePower", ReactivePower.Info },
            { "RelativeHumidity", RelativeHumidity.Info },
            { "RotationalAcceleration", RotationalAcceleration.Info },
            { "RotationalSpeed", RotationalSpeed.Info },
            { "RotationalStiffness", RotationalStiffness.Info },
            { "RotationalStiffnessPerLength", RotationalStiffnessPerLength.Info },
            { "SolidAngle", SolidAngle.Info },
            { "SpecificEnergy", SpecificEnergy.Info },
            { "SpecificEntropy", SpecificEntropy.Info },
            { "SpecificVolume", SpecificVolume.Info },
            { "SpecificWeight", SpecificWeight.Info },
            { "Speed", Speed.Info },
            { "Temperature", Temperature.Info },
            { "TemperatureChangeRate", TemperatureChangeRate.Info },
            { "TemperatureDelta", TemperatureDelta.Info },
            { "ThermalConductivity", ThermalConductivity.Info },
            { "ThermalResistance", ThermalResistance.Info },
            { "Torque", Torque.Info },
            { "TorquePerLength", TorquePerLength.Info },
            { "Turbidity", Turbidity.Info },
            { "VitaminA", VitaminA.Info },
            { "Volume", Volume.Info },
            { "VolumeConcentration", VolumeConcentration.Info },
            { "VolumeFlow", VolumeFlow.Info },
            { "VolumePerLength", VolumePerLength.Info },
            { "WarpingMomentOfInertia", WarpingMomentOfInertia.Info },
        };

        // Used by the QuantityInfo .ctor to map a name to a QuantityType. Will be removed when QuantityType
        // will be removed.
        internal static readonly IDictionary<string, QuantityType> QuantityTypeByName = new Dictionary<string, QuantityType>
        {
            { "Acceleration", QuantityType.Acceleration },
            { "AmountOfSubstance", QuantityType.AmountOfSubstance },
            { "AmplitudeRatio", QuantityType.AmplitudeRatio },
            { "Angle", QuantityType.Angle },
            { "ApparentEnergy", QuantityType.ApparentEnergy },
            { "ApparentPower", QuantityType.ApparentPower },
            { "Area", QuantityType.Area },
            { "AreaDensity", QuantityType.AreaDensity },
            { "AreaMomentOfInertia", QuantityType.AreaMomentOfInertia },
            { "BitRate", QuantityType.BitRate },
            { "BrakeSpecificFuelConsumption", QuantityType.BrakeSpecificFuelConsumption },
            { "Capacitance", QuantityType.Capacitance },
            { "CoefficientOfThermalExpansion", QuantityType.CoefficientOfThermalExpansion },
            { "Density", QuantityType.Density },
            { "Duration", QuantityType.Duration },
            { "DynamicViscosity", QuantityType.DynamicViscosity },
            { "ElectricAdmittance", QuantityType.ElectricAdmittance },
            { "ElectricCharge", QuantityType.ElectricCharge },
            { "ElectricChargeDensity", QuantityType.ElectricChargeDensity },
            { "ElectricConductance", QuantityType.ElectricConductance },
            { "ElectricConductivity", QuantityType.ElectricConductivity },
            { "ElectricCurrent", QuantityType.ElectricCurrent },
            { "ElectricCurrentDensity", QuantityType.ElectricCurrentDensity },
            { "ElectricCurrentGradient", QuantityType.ElectricCurrentGradient },
            { "ElectricField", QuantityType.ElectricField },
            { "ElectricInductance", QuantityType.ElectricInductance },
            { "ElectricPotential", QuantityType.ElectricPotential },
            { "ElectricPotentialAc", QuantityType.ElectricPotentialAc },
            { "ElectricPotentialChangeRate", QuantityType.ElectricPotentialChangeRate },
            { "ElectricPotentialDc", QuantityType.ElectricPotentialDc },
            { "ElectricResistance", QuantityType.ElectricResistance },
            { "ElectricResistivity", QuantityType.ElectricResistivity },
            { "ElectricSurfaceChargeDensity", QuantityType.ElectricSurfaceChargeDensity },
            { "Energy", QuantityType.Energy },
            { "Entropy", QuantityType.Entropy },
            { "Force", QuantityType.Force },
            { "ForceChangeRate", QuantityType.ForceChangeRate },
            { "ForcePerLength", QuantityType.ForcePerLength },
            { "Frequency", QuantityType.Frequency },
            { "FuelEfficiency", QuantityType.FuelEfficiency },
            { "HeatFlux", QuantityType.HeatFlux },
            { "HeatTransferCoefficient", QuantityType.HeatTransferCoefficient },
            { "Illuminance", QuantityType.Illuminance },
            { "Information", QuantityType.Information },
            { "Irradiance", QuantityType.Irradiance },
            { "Irradiation", QuantityType.Irradiation },
            { "KinematicViscosity", QuantityType.KinematicViscosity },
            { "LapseRate", QuantityType.LapseRate },
            { "Length", QuantityType.Length },
            { "Level", QuantityType.Level },
            { "LinearDensity", QuantityType.LinearDensity },
            { "LinearPowerDensity", QuantityType.LinearPowerDensity },
            { "Luminosity", QuantityType.Luminosity },
            { "LuminousFlux", QuantityType.LuminousFlux },
            { "LuminousIntensity", QuantityType.LuminousIntensity },
            { "MagneticField", QuantityType.MagneticField },
            { "MagneticFlux", QuantityType.MagneticFlux },
            { "Magnetization", QuantityType.Magnetization },
            { "Mass", QuantityType.Mass },
            { "MassConcentration", QuantityType.MassConcentration },
            { "MassFlow", QuantityType.MassFlow },
            { "MassFlux", QuantityType.MassFlux },
            { "MassFraction", QuantityType.MassFraction },
            { "MassMomentOfInertia", QuantityType.MassMomentOfInertia },
            { "MolarEnergy", QuantityType.MolarEnergy },
            { "MolarEntropy", QuantityType.MolarEntropy },
            { "Molarity", QuantityType.Molarity },
            { "MolarMass", QuantityType.MolarMass },
            { "Permeability", QuantityType.Permeability },
            { "Permittivity", QuantityType.Permittivity },
            { "Power", QuantityType.Power },
            { "PowerDensity", QuantityType.PowerDensity },
            { "PowerRatio", QuantityType.PowerRatio },
            { "Pressure", QuantityType.Pressure },
            { "PressureChangeRate", QuantityType.PressureChangeRate },
            { "Ratio", QuantityType.Ratio },
            { "RatioChangeRate", QuantityType.RatioChangeRate },
            { "ReactiveEnergy", QuantityType.ReactiveEnergy },
            { "ReactivePower", QuantityType.ReactivePower },
            { "RelativeHumidity", QuantityType.RelativeHumidity },
            { "RotationalAcceleration", QuantityType.RotationalAcceleration },
            { "RotationalSpeed", QuantityType.RotationalSpeed },
            { "RotationalStiffness", QuantityType.RotationalStiffness },
            { "RotationalStiffnessPerLength", QuantityType.RotationalStiffnessPerLength },
            { "SolidAngle", QuantityType.SolidAngle },
            { "SpecificEnergy", QuantityType.SpecificEnergy },
            { "SpecificEntropy", QuantityType.SpecificEntropy },
            { "SpecificVolume", QuantityType.SpecificVolume },
            { "SpecificWeight", QuantityType.SpecificWeight },
            { "Speed", QuantityType.Speed },
            { "Temperature", QuantityType.Temperature },
            { "TemperatureChangeRate", QuantityType.TemperatureChangeRate },
            { "TemperatureDelta", QuantityType.TemperatureDelta },
            { "ThermalConductivity", QuantityType.ThermalConductivity },
            { "ThermalResistance", QuantityType.ThermalResistance },
            { "Torque", QuantityType.Torque },
            { "TorquePerLength", QuantityType.TorquePerLength },
            { "Turbidity", QuantityType.Turbidity },
            { "VitaminA", QuantityType.VitaminA },
            { "Volume", QuantityType.Volume },
            { "VolumeConcentration", QuantityType.VolumeConcentration },
            { "VolumeFlow", QuantityType.VolumeFlow },
            { "VolumePerLength", QuantityType.VolumePerLength },
            { "WarpingMomentOfInertia", QuantityType.WarpingMomentOfInertia },
        };

        /// <summary>
        /// Dynamically constructs a quantity of the given <see cref="QuantityType"/> with the value in the quantity's base units.
        /// </summary>
        /// <param name="quantityType">The <see cref="QuantityType"/> of the quantity to create.</param>
        /// <param name="value">The value to construct the quantity with.</param>
        /// <returns>The created quantity.</returns>
        [Obsolete("QuantityType will be removed. Use FromQuantityInfo(QuantityInfo, QuantityValue) instead.")]
        public static IQuantity FromQuantityType<T>(QuantityType quantityType, QuantityValue value)
        {
            switch(quantityType)
            {
                case QuantityType.Acceleration:
                    return Acceleration<T>.From(value, Acceleration<T>.BaseUnit);
                case QuantityType.AmountOfSubstance:
                    return AmountOfSubstance<T>.From(value, AmountOfSubstance<T>.BaseUnit);
                case QuantityType.AmplitudeRatio:
                    return AmplitudeRatio<T>.From(value, AmplitudeRatio<T>.BaseUnit);
                case QuantityType.Angle:
                    return Angle<T>.From(value, Angle<T>.BaseUnit);
                case QuantityType.ApparentEnergy:
                    return ApparentEnergy<T>.From(value, ApparentEnergy<T>.BaseUnit);
                case QuantityType.ApparentPower:
                    return ApparentPower<T>.From(value, ApparentPower<T>.BaseUnit);
                case QuantityType.Area:
                    return Area<T>.From(value, Area<T>.BaseUnit);
                case QuantityType.AreaDensity:
                    return AreaDensity<T>.From(value, AreaDensity<T>.BaseUnit);
                case QuantityType.AreaMomentOfInertia:
                    return AreaMomentOfInertia<T>.From(value, AreaMomentOfInertia<T>.BaseUnit);
                case QuantityType.BitRate:
                    return BitRate<T>.From(value, BitRate<T>.BaseUnit);
                case QuantityType.BrakeSpecificFuelConsumption:
                    return BrakeSpecificFuelConsumption<T>.From(value, BrakeSpecificFuelConsumption<T>.BaseUnit);
                case QuantityType.Capacitance:
                    return Capacitance<T>.From(value, Capacitance<T>.BaseUnit);
                case QuantityType.CoefficientOfThermalExpansion:
                    return CoefficientOfThermalExpansion<T>.From(value, CoefficientOfThermalExpansion<T>.BaseUnit);
                case QuantityType.Density:
                    return Density<T>.From(value, Density<T>.BaseUnit);
                case QuantityType.Duration:
                    return Duration<T>.From(value, Duration<T>.BaseUnit);
                case QuantityType.DynamicViscosity:
                    return DynamicViscosity<T>.From(value, DynamicViscosity<T>.BaseUnit);
                case QuantityType.ElectricAdmittance:
                    return ElectricAdmittance<T>.From(value, ElectricAdmittance<T>.BaseUnit);
                case QuantityType.ElectricCharge:
                    return ElectricCharge<T>.From(value, ElectricCharge<T>.BaseUnit);
                case QuantityType.ElectricChargeDensity:
                    return ElectricChargeDensity<T>.From(value, ElectricChargeDensity<T>.BaseUnit);
                case QuantityType.ElectricConductance:
                    return ElectricConductance<T>.From(value, ElectricConductance<T>.BaseUnit);
                case QuantityType.ElectricConductivity:
                    return ElectricConductivity<T>.From(value, ElectricConductivity<T>.BaseUnit);
                case QuantityType.ElectricCurrent:
                    return ElectricCurrent<T>.From(value, ElectricCurrent<T>.BaseUnit);
                case QuantityType.ElectricCurrentDensity:
                    return ElectricCurrentDensity<T>.From(value, ElectricCurrentDensity<T>.BaseUnit);
                case QuantityType.ElectricCurrentGradient:
                    return ElectricCurrentGradient<T>.From(value, ElectricCurrentGradient<T>.BaseUnit);
                case QuantityType.ElectricField:
                    return ElectricField<T>.From(value, ElectricField<T>.BaseUnit);
                case QuantityType.ElectricInductance:
                    return ElectricInductance<T>.From(value, ElectricInductance<T>.BaseUnit);
                case QuantityType.ElectricPotential:
                    return ElectricPotential<T>.From(value, ElectricPotential<T>.BaseUnit);
                case QuantityType.ElectricPotentialAc:
                    return ElectricPotentialAc<T>.From(value, ElectricPotentialAc<T>.BaseUnit);
                case QuantityType.ElectricPotentialChangeRate:
                    return ElectricPotentialChangeRate<T>.From(value, ElectricPotentialChangeRate<T>.BaseUnit);
                case QuantityType.ElectricPotentialDc:
                    return ElectricPotentialDc<T>.From(value, ElectricPotentialDc<T>.BaseUnit);
                case QuantityType.ElectricResistance:
                    return ElectricResistance<T>.From(value, ElectricResistance<T>.BaseUnit);
                case QuantityType.ElectricResistivity:
                    return ElectricResistivity<T>.From(value, ElectricResistivity<T>.BaseUnit);
                case QuantityType.ElectricSurfaceChargeDensity:
                    return ElectricSurfaceChargeDensity<T>.From(value, ElectricSurfaceChargeDensity<T>.BaseUnit);
                case QuantityType.Energy:
                    return Energy<T>.From(value, Energy<T>.BaseUnit);
                case QuantityType.Entropy:
                    return Entropy<T>.From(value, Entropy<T>.BaseUnit);
                case QuantityType.Force:
                    return Force<T>.From(value, Force<T>.BaseUnit);
                case QuantityType.ForceChangeRate:
                    return ForceChangeRate<T>.From(value, ForceChangeRate<T>.BaseUnit);
                case QuantityType.ForcePerLength:
                    return ForcePerLength<T>.From(value, ForcePerLength<T>.BaseUnit);
                case QuantityType.Frequency:
                    return Frequency<T>.From(value, Frequency<T>.BaseUnit);
                case QuantityType.FuelEfficiency:
                    return FuelEfficiency<T>.From(value, FuelEfficiency<T>.BaseUnit);
                case QuantityType.HeatFlux:
                    return HeatFlux<T>.From(value, HeatFlux<T>.BaseUnit);
                case QuantityType.HeatTransferCoefficient:
                    return HeatTransferCoefficient<T>.From(value, HeatTransferCoefficient<T>.BaseUnit);
                case QuantityType.Illuminance:
                    return Illuminance<T>.From(value, Illuminance<T>.BaseUnit);
                case QuantityType.Information:
                    return Information<T>.From(value, Information<T>.BaseUnit);
                case QuantityType.Irradiance:
                    return Irradiance<T>.From(value, Irradiance<T>.BaseUnit);
                case QuantityType.Irradiation:
                    return Irradiation<T>.From(value, Irradiation<T>.BaseUnit);
                case QuantityType.KinematicViscosity:
                    return KinematicViscosity<T>.From(value, KinematicViscosity<T>.BaseUnit);
                case QuantityType.LapseRate:
                    return LapseRate<T>.From(value, LapseRate<T>.BaseUnit);
                case QuantityType.Length:
                    return Length<T>.From(value, Length<T>.BaseUnit);
                case QuantityType.Level:
                    return Level<T>.From(value, Level<T>.BaseUnit);
                case QuantityType.LinearDensity:
                    return LinearDensity<T>.From(value, LinearDensity<T>.BaseUnit);
                case QuantityType.LinearPowerDensity:
                    return LinearPowerDensity<T>.From(value, LinearPowerDensity<T>.BaseUnit);
                case QuantityType.Luminosity:
                    return Luminosity<T>.From(value, Luminosity<T>.BaseUnit);
                case QuantityType.LuminousFlux:
                    return LuminousFlux<T>.From(value, LuminousFlux<T>.BaseUnit);
                case QuantityType.LuminousIntensity:
                    return LuminousIntensity<T>.From(value, LuminousIntensity<T>.BaseUnit);
                case QuantityType.MagneticField:
                    return MagneticField<T>.From(value, MagneticField<T>.BaseUnit);
                case QuantityType.MagneticFlux:
                    return MagneticFlux<T>.From(value, MagneticFlux<T>.BaseUnit);
                case QuantityType.Magnetization:
                    return Magnetization<T>.From(value, Magnetization<T>.BaseUnit);
                case QuantityType.Mass:
                    return Mass<T>.From(value, Mass<T>.BaseUnit);
                case QuantityType.MassConcentration:
                    return MassConcentration<T>.From(value, MassConcentration<T>.BaseUnit);
                case QuantityType.MassFlow:
                    return MassFlow<T>.From(value, MassFlow<T>.BaseUnit);
                case QuantityType.MassFlux:
                    return MassFlux<T>.From(value, MassFlux<T>.BaseUnit);
                case QuantityType.MassFraction:
                    return MassFraction<T>.From(value, MassFraction<T>.BaseUnit);
                case QuantityType.MassMomentOfInertia:
                    return MassMomentOfInertia<T>.From(value, MassMomentOfInertia<T>.BaseUnit);
                case QuantityType.MolarEnergy:
                    return MolarEnergy<T>.From(value, MolarEnergy<T>.BaseUnit);
                case QuantityType.MolarEntropy:
                    return MolarEntropy<T>.From(value, MolarEntropy<T>.BaseUnit);
                case QuantityType.Molarity:
                    return Molarity<T>.From(value, Molarity<T>.BaseUnit);
                case QuantityType.MolarMass:
                    return MolarMass<T>.From(value, MolarMass<T>.BaseUnit);
                case QuantityType.Permeability:
                    return Permeability<T>.From(value, Permeability<T>.BaseUnit);
                case QuantityType.Permittivity:
                    return Permittivity<T>.From(value, Permittivity<T>.BaseUnit);
                case QuantityType.Power:
                    return Power<T>.From(value, Power<T>.BaseUnit);
                case QuantityType.PowerDensity:
                    return PowerDensity<T>.From(value, PowerDensity<T>.BaseUnit);
                case QuantityType.PowerRatio:
                    return PowerRatio<T>.From(value, PowerRatio<T>.BaseUnit);
                case QuantityType.Pressure:
                    return Pressure<T>.From(value, Pressure<T>.BaseUnit);
                case QuantityType.PressureChangeRate:
                    return PressureChangeRate<T>.From(value, PressureChangeRate<T>.BaseUnit);
                case QuantityType.Ratio:
                    return Ratio<T>.From(value, Ratio<T>.BaseUnit);
                case QuantityType.RatioChangeRate:
                    return RatioChangeRate<T>.From(value, RatioChangeRate<T>.BaseUnit);
                case QuantityType.ReactiveEnergy:
                    return ReactiveEnergy<T>.From(value, ReactiveEnergy<T>.BaseUnit);
                case QuantityType.ReactivePower:
                    return ReactivePower<T>.From(value, ReactivePower<T>.BaseUnit);
                case QuantityType.RelativeHumidity:
                    return RelativeHumidity<T>.From(value, RelativeHumidity<T>.BaseUnit);
                case QuantityType.RotationalAcceleration:
                    return RotationalAcceleration<T>.From(value, RotationalAcceleration<T>.BaseUnit);
                case QuantityType.RotationalSpeed:
                    return RotationalSpeed<T>.From(value, RotationalSpeed<T>.BaseUnit);
                case QuantityType.RotationalStiffness:
                    return RotationalStiffness<T>.From(value, RotationalStiffness<T>.BaseUnit);
                case QuantityType.RotationalStiffnessPerLength:
                    return RotationalStiffnessPerLength<T>.From(value, RotationalStiffnessPerLength<T>.BaseUnit);
                case QuantityType.SolidAngle:
                    return SolidAngle<T>.From(value, SolidAngle<T>.BaseUnit);
                case QuantityType.SpecificEnergy:
                    return SpecificEnergy<T>.From(value, SpecificEnergy<T>.BaseUnit);
                case QuantityType.SpecificEntropy:
                    return SpecificEntropy<T>.From(value, SpecificEntropy<T>.BaseUnit);
                case QuantityType.SpecificVolume:
                    return SpecificVolume<T>.From(value, SpecificVolume<T>.BaseUnit);
                case QuantityType.SpecificWeight:
                    return SpecificWeight<T>.From(value, SpecificWeight<T>.BaseUnit);
                case QuantityType.Speed:
                    return Speed<T>.From(value, Speed<T>.BaseUnit);
                case QuantityType.Temperature:
                    return Temperature<T>.From(value, Temperature<T>.BaseUnit);
                case QuantityType.TemperatureChangeRate:
                    return TemperatureChangeRate<T>.From(value, TemperatureChangeRate<T>.BaseUnit);
                case QuantityType.TemperatureDelta:
                    return TemperatureDelta<T>.From(value, TemperatureDelta<T>.BaseUnit);
                case QuantityType.ThermalConductivity:
                    return ThermalConductivity<T>.From(value, ThermalConductivity<T>.BaseUnit);
                case QuantityType.ThermalResistance:
                    return ThermalResistance<T>.From(value, ThermalResistance<T>.BaseUnit);
                case QuantityType.Torque:
                    return Torque<T>.From(value, Torque<T>.BaseUnit);
                case QuantityType.TorquePerLength:
                    return TorquePerLength<T>.From(value, TorquePerLength<T>.BaseUnit);
                case QuantityType.Turbidity:
                    return Turbidity<T>.From(value, Turbidity<T>.BaseUnit);
                case QuantityType.VitaminA:
                    return VitaminA<T>.From(value, VitaminA<T>.BaseUnit);
                case QuantityType.Volume:
                    return Volume<T>.From(value, Volume<T>.BaseUnit);
                case QuantityType.VolumeConcentration:
                    return VolumeConcentration<T>.From(value, VolumeConcentration<T>.BaseUnit);
                case QuantityType.VolumeFlow:
                    return VolumeFlow<T>.From(value, VolumeFlow<T>.BaseUnit);
                case QuantityType.VolumePerLength:
                    return VolumePerLength<T>.From(value, VolumePerLength<T>.BaseUnit);
                case QuantityType.WarpingMomentOfInertia:
                    return WarpingMomentOfInertia<T>.From(value, WarpingMomentOfInertia<T>.BaseUnit);
                default:
                    throw new ArgumentException($"{quantityType} is not a supported quantity type.");
            }
        }

        /// <summary>
        /// Dynamically constructs a quantity of the given <see cref="QuantityInfo"/> with the value in the quantity's base units.
        /// </summary>
        /// <param name="quantityInfo">The <see cref="QuantityInfo"/> of the quantity to create.</param>
        /// <param name="value">The value to construct the quantity with.</param>
        /// <returns>The created quantity.</returns>
        public static IQuantity FromQuantityInfo(QuantityInfo quantityInfo, QuantityValue value)
        {
            switch(quantityInfo.Name)
            {
                case "Acceleration":
                    return Acceleration.From(value, Acceleration.BaseUnit);
                case "AmountOfSubstance":
                    return AmountOfSubstance.From(value, AmountOfSubstance.BaseUnit);
                case "AmplitudeRatio":
                    return AmplitudeRatio.From(value, AmplitudeRatio.BaseUnit);
                case "Angle":
                    return Angle.From(value, Angle.BaseUnit);
                case "ApparentEnergy":
                    return ApparentEnergy.From(value, ApparentEnergy.BaseUnit);
                case "ApparentPower":
                    return ApparentPower.From(value, ApparentPower.BaseUnit);
                case "Area":
                    return Area.From(value, Area.BaseUnit);
                case "AreaDensity":
                    return AreaDensity.From(value, AreaDensity.BaseUnit);
                case "AreaMomentOfInertia":
                    return AreaMomentOfInertia.From(value, AreaMomentOfInertia.BaseUnit);
                case "BitRate":
                    return BitRate.From(value, BitRate.BaseUnit);
                case "BrakeSpecificFuelConsumption":
                    return BrakeSpecificFuelConsumption.From(value, BrakeSpecificFuelConsumption.BaseUnit);
                case "Capacitance":
                    return Capacitance.From(value, Capacitance.BaseUnit);
                case "CoefficientOfThermalExpansion":
                    return CoefficientOfThermalExpansion.From(value, CoefficientOfThermalExpansion.BaseUnit);
                case "Density":
                    return Density.From(value, Density.BaseUnit);
                case "Duration":
                    return Duration.From(value, Duration.BaseUnit);
                case "DynamicViscosity":
                    return DynamicViscosity.From(value, DynamicViscosity.BaseUnit);
                case "ElectricAdmittance":
                    return ElectricAdmittance.From(value, ElectricAdmittance.BaseUnit);
                case "ElectricCharge":
                    return ElectricCharge.From(value, ElectricCharge.BaseUnit);
                case "ElectricChargeDensity":
                    return ElectricChargeDensity.From(value, ElectricChargeDensity.BaseUnit);
                case "ElectricConductance":
                    return ElectricConductance.From(value, ElectricConductance.BaseUnit);
                case "ElectricConductivity":
                    return ElectricConductivity.From(value, ElectricConductivity.BaseUnit);
                case "ElectricCurrent":
                    return ElectricCurrent.From(value, ElectricCurrent.BaseUnit);
                case "ElectricCurrentDensity":
                    return ElectricCurrentDensity.From(value, ElectricCurrentDensity.BaseUnit);
                case "ElectricCurrentGradient":
                    return ElectricCurrentGradient.From(value, ElectricCurrentGradient.BaseUnit);
                case "ElectricField":
                    return ElectricField.From(value, ElectricField.BaseUnit);
                case "ElectricInductance":
                    return ElectricInductance.From(value, ElectricInductance.BaseUnit);
                case "ElectricPotential":
                    return ElectricPotential.From(value, ElectricPotential.BaseUnit);
                case "ElectricPotentialAc":
                    return ElectricPotentialAc.From(value, ElectricPotentialAc.BaseUnit);
                case "ElectricPotentialChangeRate":
                    return ElectricPotentialChangeRate.From(value, ElectricPotentialChangeRate.BaseUnit);
                case "ElectricPotentialDc":
                    return ElectricPotentialDc.From(value, ElectricPotentialDc.BaseUnit);
                case "ElectricResistance":
                    return ElectricResistance.From(value, ElectricResistance.BaseUnit);
                case "ElectricResistivity":
                    return ElectricResistivity.From(value, ElectricResistivity.BaseUnit);
                case "ElectricSurfaceChargeDensity":
                    return ElectricSurfaceChargeDensity.From(value, ElectricSurfaceChargeDensity.BaseUnit);
                case "Energy":
                    return Energy.From(value, Energy.BaseUnit);
                case "Entropy":
                    return Entropy.From(value, Entropy.BaseUnit);
                case "Force":
                    return Force.From(value, Force.BaseUnit);
                case "ForceChangeRate":
                    return ForceChangeRate.From(value, ForceChangeRate.BaseUnit);
                case "ForcePerLength":
                    return ForcePerLength.From(value, ForcePerLength.BaseUnit);
                case "Frequency":
                    return Frequency.From(value, Frequency.BaseUnit);
                case "FuelEfficiency":
                    return FuelEfficiency.From(value, FuelEfficiency.BaseUnit);
                case "HeatFlux":
                    return HeatFlux.From(value, HeatFlux.BaseUnit);
                case "HeatTransferCoefficient":
                    return HeatTransferCoefficient.From(value, HeatTransferCoefficient.BaseUnit);
                case "Illuminance":
                    return Illuminance.From(value, Illuminance.BaseUnit);
                case "Information":
                    return Information.From(value, Information.BaseUnit);
                case "Irradiance":
                    return Irradiance.From(value, Irradiance.BaseUnit);
                case "Irradiation":
                    return Irradiation.From(value, Irradiation.BaseUnit);
                case "KinematicViscosity":
                    return KinematicViscosity.From(value, KinematicViscosity.BaseUnit);
                case "LapseRate":
                    return LapseRate.From(value, LapseRate.BaseUnit);
                case "Length":
                    return Length.From(value, Length.BaseUnit);
                case "Level":
                    return Level.From(value, Level.BaseUnit);
                case "LinearDensity":
                    return LinearDensity.From(value, LinearDensity.BaseUnit);
                case "LinearPowerDensity":
                    return LinearPowerDensity.From(value, LinearPowerDensity.BaseUnit);
                case "Luminosity":
                    return Luminosity.From(value, Luminosity.BaseUnit);
                case "LuminousFlux":
                    return LuminousFlux.From(value, LuminousFlux.BaseUnit);
                case "LuminousIntensity":
                    return LuminousIntensity.From(value, LuminousIntensity.BaseUnit);
                case "MagneticField":
                    return MagneticField.From(value, MagneticField.BaseUnit);
                case "MagneticFlux":
                    return MagneticFlux.From(value, MagneticFlux.BaseUnit);
                case "Magnetization":
                    return Magnetization.From(value, Magnetization.BaseUnit);
                case "Mass":
                    return Mass.From(value, Mass.BaseUnit);
                case "MassConcentration":
                    return MassConcentration.From(value, MassConcentration.BaseUnit);
                case "MassFlow":
                    return MassFlow.From(value, MassFlow.BaseUnit);
                case "MassFlux":
                    return MassFlux.From(value, MassFlux.BaseUnit);
                case "MassFraction":
                    return MassFraction.From(value, MassFraction.BaseUnit);
                case "MassMomentOfInertia":
                    return MassMomentOfInertia.From(value, MassMomentOfInertia.BaseUnit);
                case "MolarEnergy":
                    return MolarEnergy.From(value, MolarEnergy.BaseUnit);
                case "MolarEntropy":
                    return MolarEntropy.From(value, MolarEntropy.BaseUnit);
                case "Molarity":
                    return Molarity.From(value, Molarity.BaseUnit);
                case "MolarMass":
                    return MolarMass.From(value, MolarMass.BaseUnit);
                case "Permeability":
                    return Permeability.From(value, Permeability.BaseUnit);
                case "Permittivity":
                    return Permittivity.From(value, Permittivity.BaseUnit);
                case "Power":
                    return Power.From(value, Power.BaseUnit);
                case "PowerDensity":
                    return PowerDensity.From(value, PowerDensity.BaseUnit);
                case "PowerRatio":
                    return PowerRatio.From(value, PowerRatio.BaseUnit);
                case "Pressure":
                    return Pressure.From(value, Pressure.BaseUnit);
                case "PressureChangeRate":
                    return PressureChangeRate.From(value, PressureChangeRate.BaseUnit);
                case "Ratio":
                    return Ratio.From(value, Ratio.BaseUnit);
                case "RatioChangeRate":
                    return RatioChangeRate.From(value, RatioChangeRate.BaseUnit);
                case "ReactiveEnergy":
                    return ReactiveEnergy.From(value, ReactiveEnergy.BaseUnit);
                case "ReactivePower":
                    return ReactivePower.From(value, ReactivePower.BaseUnit);
                case "RelativeHumidity":
                    return RelativeHumidity.From(value, RelativeHumidity.BaseUnit);
                case "RotationalAcceleration":
                    return RotationalAcceleration.From(value, RotationalAcceleration.BaseUnit);
                case "RotationalSpeed":
                    return RotationalSpeed.From(value, RotationalSpeed.BaseUnit);
                case "RotationalStiffness":
                    return RotationalStiffness.From(value, RotationalStiffness.BaseUnit);
                case "RotationalStiffnessPerLength":
                    return RotationalStiffnessPerLength.From(value, RotationalStiffnessPerLength.BaseUnit);
                case "SolidAngle":
                    return SolidAngle.From(value, SolidAngle.BaseUnit);
                case "SpecificEnergy":
                    return SpecificEnergy.From(value, SpecificEnergy.BaseUnit);
                case "SpecificEntropy":
                    return SpecificEntropy.From(value, SpecificEntropy.BaseUnit);
                case "SpecificVolume":
                    return SpecificVolume.From(value, SpecificVolume.BaseUnit);
                case "SpecificWeight":
                    return SpecificWeight.From(value, SpecificWeight.BaseUnit);
                case "Speed":
                    return Speed.From(value, Speed.BaseUnit);
                case "Temperature":
                    return Temperature.From(value, Temperature.BaseUnit);
                case "TemperatureChangeRate":
                    return TemperatureChangeRate.From(value, TemperatureChangeRate.BaseUnit);
                case "TemperatureDelta":
                    return TemperatureDelta.From(value, TemperatureDelta.BaseUnit);
                case "ThermalConductivity":
                    return ThermalConductivity.From(value, ThermalConductivity.BaseUnit);
                case "ThermalResistance":
                    return ThermalResistance.From(value, ThermalResistance.BaseUnit);
                case "Torque":
                    return Torque.From(value, Torque.BaseUnit);
                case "TorquePerLength":
                    return TorquePerLength.From(value, TorquePerLength.BaseUnit);
                case "Turbidity":
                    return Turbidity.From(value, Turbidity.BaseUnit);
                case "VitaminA":
                    return VitaminA.From(value, VitaminA.BaseUnit);
                case "Volume":
                    return Volume.From(value, Volume.BaseUnit);
                case "VolumeConcentration":
                    return VolumeConcentration.From(value, VolumeConcentration.BaseUnit);
                case "VolumeFlow":
                    return VolumeFlow.From(value, VolumeFlow.BaseUnit);
                case "VolumePerLength":
                    return VolumePerLength.From(value, VolumePerLength.BaseUnit);
                case "WarpingMomentOfInertia":
                    return WarpingMomentOfInertia.From(value, WarpingMomentOfInertia.BaseUnit);
                default:
                    throw new ArgumentException($"{quantityInfo.Name} is not a supported quantity.");
            }
        }

        /// <summary>
        ///     Try to dynamically construct a quantity.
        /// </summary>
        /// <param name="value">Numeric value.</param>
        /// <param name="unit">Unit enum value.</param>
        /// <param name="quantity">The resulting quantity if successful, otherwise <c>default</c>.</param>
        /// <returns><c>True</c> if successful with <paramref name="quantity"/> assigned the value, otherwise <c>false</c>.</returns>
        public static bool TryFrom<T>(QuantityValue value, Enum unit, out IQuantity? quantity)
        {
            switch (unit)
            {
                case AccelerationUnit accelerationUnit:
                    quantity = Acceleration<T>.From(value, accelerationUnit);
                    return true;
                case AmountOfSubstanceUnit amountOfSubstanceUnit:
                    quantity = AmountOfSubstance<T>.From(value, amountOfSubstanceUnit);
                    return true;
                case AmplitudeRatioUnit amplitudeRatioUnit:
                    quantity = AmplitudeRatio<T>.From(value, amplitudeRatioUnit);
                    return true;
                case AngleUnit angleUnit:
                    quantity = Angle<T>.From(value, angleUnit);
                    return true;
                case ApparentEnergyUnit apparentEnergyUnit:
                    quantity = ApparentEnergy<T>.From(value, apparentEnergyUnit);
                    return true;
                case ApparentPowerUnit apparentPowerUnit:
                    quantity = ApparentPower<T>.From(value, apparentPowerUnit);
                    return true;
                case AreaUnit areaUnit:
                    quantity = Area<T>.From(value, areaUnit);
                    return true;
                case AreaDensityUnit areaDensityUnit:
                    quantity = AreaDensity<T>.From(value, areaDensityUnit);
                    return true;
                case AreaMomentOfInertiaUnit areaMomentOfInertiaUnit:
                    quantity = AreaMomentOfInertia<T>.From(value, areaMomentOfInertiaUnit);
                    return true;
                case BitRateUnit bitRateUnit:
                    quantity = BitRate<T>.From(value, bitRateUnit);
                    return true;
                case BrakeSpecificFuelConsumptionUnit brakeSpecificFuelConsumptionUnit:
                    quantity = BrakeSpecificFuelConsumption<T>.From(value, brakeSpecificFuelConsumptionUnit);
                    return true;
                case CapacitanceUnit capacitanceUnit:
                    quantity = Capacitance<T>.From(value, capacitanceUnit);
                    return true;
                case CoefficientOfThermalExpansionUnit coefficientOfThermalExpansionUnit:
                    quantity = CoefficientOfThermalExpansion<T>.From(value, coefficientOfThermalExpansionUnit);
                    return true;
                case DensityUnit densityUnit:
                    quantity = Density<T>.From(value, densityUnit);
                    return true;
                case DurationUnit durationUnit:
                    quantity = Duration<T>.From(value, durationUnit);
                    return true;
                case DynamicViscosityUnit dynamicViscosityUnit:
                    quantity = DynamicViscosity<T>.From(value, dynamicViscosityUnit);
                    return true;
                case ElectricAdmittanceUnit electricAdmittanceUnit:
                    quantity = ElectricAdmittance<T>.From(value, electricAdmittanceUnit);
                    return true;
                case ElectricChargeUnit electricChargeUnit:
                    quantity = ElectricCharge<T>.From(value, electricChargeUnit);
                    return true;
                case ElectricChargeDensityUnit electricChargeDensityUnit:
                    quantity = ElectricChargeDensity<T>.From(value, electricChargeDensityUnit);
                    return true;
                case ElectricConductanceUnit electricConductanceUnit:
                    quantity = ElectricConductance<T>.From(value, electricConductanceUnit);
                    return true;
                case ElectricConductivityUnit electricConductivityUnit:
                    quantity = ElectricConductivity<T>.From(value, electricConductivityUnit);
                    return true;
                case ElectricCurrentUnit electricCurrentUnit:
                    quantity = ElectricCurrent<T>.From(value, electricCurrentUnit);
                    return true;
                case ElectricCurrentDensityUnit electricCurrentDensityUnit:
                    quantity = ElectricCurrentDensity<T>.From(value, electricCurrentDensityUnit);
                    return true;
                case ElectricCurrentGradientUnit electricCurrentGradientUnit:
                    quantity = ElectricCurrentGradient<T>.From(value, electricCurrentGradientUnit);
                    return true;
                case ElectricFieldUnit electricFieldUnit:
                    quantity = ElectricField<T>.From(value, electricFieldUnit);
                    return true;
                case ElectricInductanceUnit electricInductanceUnit:
                    quantity = ElectricInductance<T>.From(value, electricInductanceUnit);
                    return true;
                case ElectricPotentialUnit electricPotentialUnit:
                    quantity = ElectricPotential<T>.From(value, electricPotentialUnit);
                    return true;
                case ElectricPotentialAcUnit electricPotentialAcUnit:
                    quantity = ElectricPotentialAc<T>.From(value, electricPotentialAcUnit);
                    return true;
                case ElectricPotentialChangeRateUnit electricPotentialChangeRateUnit:
                    quantity = ElectricPotentialChangeRate<T>.From(value, electricPotentialChangeRateUnit);
                    return true;
                case ElectricPotentialDcUnit electricPotentialDcUnit:
                    quantity = ElectricPotentialDc<T>.From(value, electricPotentialDcUnit);
                    return true;
                case ElectricResistanceUnit electricResistanceUnit:
                    quantity = ElectricResistance<T>.From(value, electricResistanceUnit);
                    return true;
                case ElectricResistivityUnit electricResistivityUnit:
                    quantity = ElectricResistivity<T>.From(value, electricResistivityUnit);
                    return true;
                case ElectricSurfaceChargeDensityUnit electricSurfaceChargeDensityUnit:
                    quantity = ElectricSurfaceChargeDensity<T>.From(value, electricSurfaceChargeDensityUnit);
                    return true;
                case EnergyUnit energyUnit:
                    quantity = Energy<T>.From(value, energyUnit);
                    return true;
                case EntropyUnit entropyUnit:
                    quantity = Entropy<T>.From(value, entropyUnit);
                    return true;
                case ForceUnit forceUnit:
                    quantity = Force<T>.From(value, forceUnit);
                    return true;
                case ForceChangeRateUnit forceChangeRateUnit:
                    quantity = ForceChangeRate<T>.From(value, forceChangeRateUnit);
                    return true;
                case ForcePerLengthUnit forcePerLengthUnit:
                    quantity = ForcePerLength<T>.From(value, forcePerLengthUnit);
                    return true;
                case FrequencyUnit frequencyUnit:
                    quantity = Frequency<T>.From(value, frequencyUnit);
                    return true;
                case FuelEfficiencyUnit fuelEfficiencyUnit:
                    quantity = FuelEfficiency<T>.From(value, fuelEfficiencyUnit);
                    return true;
                case HeatFluxUnit heatFluxUnit:
                    quantity = HeatFlux<T>.From(value, heatFluxUnit);
                    return true;
                case HeatTransferCoefficientUnit heatTransferCoefficientUnit:
                    quantity = HeatTransferCoefficient<T>.From(value, heatTransferCoefficientUnit);
                    return true;
                case IlluminanceUnit illuminanceUnit:
                    quantity = Illuminance<T>.From(value, illuminanceUnit);
                    return true;
                case InformationUnit informationUnit:
                    quantity = Information<T>.From(value, informationUnit);
                    return true;
                case IrradianceUnit irradianceUnit:
                    quantity = Irradiance<T>.From(value, irradianceUnit);
                    return true;
                case IrradiationUnit irradiationUnit:
                    quantity = Irradiation<T>.From(value, irradiationUnit);
                    return true;
                case KinematicViscosityUnit kinematicViscosityUnit:
                    quantity = KinematicViscosity<T>.From(value, kinematicViscosityUnit);
                    return true;
                case LapseRateUnit lapseRateUnit:
                    quantity = LapseRate<T>.From(value, lapseRateUnit);
                    return true;
                case LengthUnit lengthUnit:
                    quantity = Length<T>.From(value, lengthUnit);
                    return true;
                case LevelUnit levelUnit:
                    quantity = Level<T>.From(value, levelUnit);
                    return true;
                case LinearDensityUnit linearDensityUnit:
                    quantity = LinearDensity<T>.From(value, linearDensityUnit);
                    return true;
                case LinearPowerDensityUnit linearPowerDensityUnit:
                    quantity = LinearPowerDensity<T>.From(value, linearPowerDensityUnit);
                    return true;
                case LuminosityUnit luminosityUnit:
                    quantity = Luminosity<T>.From(value, luminosityUnit);
                    return true;
                case LuminousFluxUnit luminousFluxUnit:
                    quantity = LuminousFlux<T>.From(value, luminousFluxUnit);
                    return true;
                case LuminousIntensityUnit luminousIntensityUnit:
                    quantity = LuminousIntensity<T>.From(value, luminousIntensityUnit);
                    return true;
                case MagneticFieldUnit magneticFieldUnit:
                    quantity = MagneticField<T>.From(value, magneticFieldUnit);
                    return true;
                case MagneticFluxUnit magneticFluxUnit:
                    quantity = MagneticFlux<T>.From(value, magneticFluxUnit);
                    return true;
                case MagnetizationUnit magnetizationUnit:
                    quantity = Magnetization<T>.From(value, magnetizationUnit);
                    return true;
                case MassUnit massUnit:
                    quantity = Mass<T>.From(value, massUnit);
                    return true;
                case MassConcentrationUnit massConcentrationUnit:
                    quantity = MassConcentration<T>.From(value, massConcentrationUnit);
                    return true;
                case MassFlowUnit massFlowUnit:
                    quantity = MassFlow<T>.From(value, massFlowUnit);
                    return true;
                case MassFluxUnit massFluxUnit:
                    quantity = MassFlux<T>.From(value, massFluxUnit);
                    return true;
                case MassFractionUnit massFractionUnit:
                    quantity = MassFraction<T>.From(value, massFractionUnit);
                    return true;
                case MassMomentOfInertiaUnit massMomentOfInertiaUnit:
                    quantity = MassMomentOfInertia<T>.From(value, massMomentOfInertiaUnit);
                    return true;
                case MolarEnergyUnit molarEnergyUnit:
                    quantity = MolarEnergy<T>.From(value, molarEnergyUnit);
                    return true;
                case MolarEntropyUnit molarEntropyUnit:
                    quantity = MolarEntropy<T>.From(value, molarEntropyUnit);
                    return true;
                case MolarityUnit molarityUnit:
                    quantity = Molarity<T>.From(value, molarityUnit);
                    return true;
                case MolarMassUnit molarMassUnit:
                    quantity = MolarMass<T>.From(value, molarMassUnit);
                    return true;
                case PermeabilityUnit permeabilityUnit:
                    quantity = Permeability<T>.From(value, permeabilityUnit);
                    return true;
                case PermittivityUnit permittivityUnit:
                    quantity = Permittivity<T>.From(value, permittivityUnit);
                    return true;
                case PowerUnit powerUnit:
                    quantity = Power<T>.From(value, powerUnit);
                    return true;
                case PowerDensityUnit powerDensityUnit:
                    quantity = PowerDensity<T>.From(value, powerDensityUnit);
                    return true;
                case PowerRatioUnit powerRatioUnit:
                    quantity = PowerRatio<T>.From(value, powerRatioUnit);
                    return true;
                case PressureUnit pressureUnit:
                    quantity = Pressure<T>.From(value, pressureUnit);
                    return true;
                case PressureChangeRateUnit pressureChangeRateUnit:
                    quantity = PressureChangeRate<T>.From(value, pressureChangeRateUnit);
                    return true;
                case RatioUnit ratioUnit:
                    quantity = Ratio<T>.From(value, ratioUnit);
                    return true;
                case RatioChangeRateUnit ratioChangeRateUnit:
                    quantity = RatioChangeRate<T>.From(value, ratioChangeRateUnit);
                    return true;
                case ReactiveEnergyUnit reactiveEnergyUnit:
                    quantity = ReactiveEnergy<T>.From(value, reactiveEnergyUnit);
                    return true;
                case ReactivePowerUnit reactivePowerUnit:
                    quantity = ReactivePower<T>.From(value, reactivePowerUnit);
                    return true;
                case RelativeHumidityUnit relativeHumidityUnit:
                    quantity = RelativeHumidity<T>.From(value, relativeHumidityUnit);
                    return true;
                case RotationalAccelerationUnit rotationalAccelerationUnit:
                    quantity = RotationalAcceleration<T>.From(value, rotationalAccelerationUnit);
                    return true;
                case RotationalSpeedUnit rotationalSpeedUnit:
                    quantity = RotationalSpeed<T>.From(value, rotationalSpeedUnit);
                    return true;
                case RotationalStiffnessUnit rotationalStiffnessUnit:
                    quantity = RotationalStiffness<T>.From(value, rotationalStiffnessUnit);
                    return true;
                case RotationalStiffnessPerLengthUnit rotationalStiffnessPerLengthUnit:
                    quantity = RotationalStiffnessPerLength<T>.From(value, rotationalStiffnessPerLengthUnit);
                    return true;
                case SolidAngleUnit solidAngleUnit:
                    quantity = SolidAngle<T>.From(value, solidAngleUnit);
                    return true;
                case SpecificEnergyUnit specificEnergyUnit:
                    quantity = SpecificEnergy<T>.From(value, specificEnergyUnit);
                    return true;
                case SpecificEntropyUnit specificEntropyUnit:
                    quantity = SpecificEntropy<T>.From(value, specificEntropyUnit);
                    return true;
                case SpecificVolumeUnit specificVolumeUnit:
                    quantity = SpecificVolume<T>.From(value, specificVolumeUnit);
                    return true;
                case SpecificWeightUnit specificWeightUnit:
                    quantity = SpecificWeight<T>.From(value, specificWeightUnit);
                    return true;
                case SpeedUnit speedUnit:
                    quantity = Speed<T>.From(value, speedUnit);
                    return true;
                case TemperatureUnit temperatureUnit:
                    quantity = Temperature<T>.From(value, temperatureUnit);
                    return true;
                case TemperatureChangeRateUnit temperatureChangeRateUnit:
                    quantity = TemperatureChangeRate<T>.From(value, temperatureChangeRateUnit);
                    return true;
                case TemperatureDeltaUnit temperatureDeltaUnit:
                    quantity = TemperatureDelta<T>.From(value, temperatureDeltaUnit);
                    return true;
                case ThermalConductivityUnit thermalConductivityUnit:
                    quantity = ThermalConductivity<T>.From(value, thermalConductivityUnit);
                    return true;
                case ThermalResistanceUnit thermalResistanceUnit:
                    quantity = ThermalResistance<T>.From(value, thermalResistanceUnit);
                    return true;
                case TorqueUnit torqueUnit:
                    quantity = Torque<T>.From(value, torqueUnit);
                    return true;
                case TorquePerLengthUnit torquePerLengthUnit:
                    quantity = TorquePerLength<T>.From(value, torquePerLengthUnit);
                    return true;
                case TurbidityUnit turbidityUnit:
                    quantity = Turbidity<T>.From(value, turbidityUnit);
                    return true;
                case VitaminAUnit vitaminAUnit:
                    quantity = VitaminA<T>.From(value, vitaminAUnit);
                    return true;
                case VolumeUnit volumeUnit:
                    quantity = Volume<T>.From(value, volumeUnit);
                    return true;
                case VolumeConcentrationUnit volumeConcentrationUnit:
                    quantity = VolumeConcentration<T>.From(value, volumeConcentrationUnit);
                    return true;
                case VolumeFlowUnit volumeFlowUnit:
                    quantity = VolumeFlow<T>.From(value, volumeFlowUnit);
                    return true;
                case VolumePerLengthUnit volumePerLengthUnit:
                    quantity = VolumePerLength<T>.From(value, volumePerLengthUnit);
                    return true;
                case WarpingMomentOfInertiaUnit warpingMomentOfInertiaUnit:
                    quantity = WarpingMomentOfInertia<T>.From(value, warpingMomentOfInertiaUnit);
                    return true;
                default:
                {
                    quantity = default(IQuantity);
                    return false;
                }
            }
        }

        /// <summary>
        ///     Try to dynamically parse a quantity string representation.
        /// </summary>
        /// <param name="formatProvider">The format provider to use for lookup. Defaults to <see cref="CultureInfo.CurrentUICulture" /> if null.</param>
        /// <param name="quantityType">Type of quantity, such as <see cref="Length{T}"/>.</param>
        /// <param name="quantityString">Quantity string representation, such as "1.5 kg". Must be compatible with given quantity type.</param>
        /// <param name="quantity">The resulting quantity if successful, otherwise <c>default</c>.</param>
        /// <returns>The parsed quantity.</returns>
        public static bool TryParse<T>(IFormatProvider? formatProvider, Type quantityType, string quantityString, out IQuantity? quantity)
        {
            quantity = default(IQuantity);

            if (!typeof(IQuantity).Wrap().IsAssignableFrom(quantityType))
                return false;

            var parser = QuantityParser.Default;

            switch(quantityType)
            {
                case Type _ when quantityType == typeof(Acceleration<T>):
                    return parser.TryParse<Acceleration<T>, AccelerationUnit>(quantityString, formatProvider, Acceleration<T>.From, out quantity);
                case Type _ when quantityType == typeof(AmountOfSubstance<T>):
                    return parser.TryParse<AmountOfSubstance<T>, AmountOfSubstanceUnit>(quantityString, formatProvider, AmountOfSubstance<T>.From, out quantity);
                case Type _ when quantityType == typeof(AmplitudeRatio<T>):
                    return parser.TryParse<AmplitudeRatio<T>, AmplitudeRatioUnit>(quantityString, formatProvider, AmplitudeRatio<T>.From, out quantity);
                case Type _ when quantityType == typeof(Angle<T>):
                    return parser.TryParse<Angle<T>, AngleUnit>(quantityString, formatProvider, Angle<T>.From, out quantity);
                case Type _ when quantityType == typeof(ApparentEnergy<T>):
                    return parser.TryParse<ApparentEnergy<T>, ApparentEnergyUnit>(quantityString, formatProvider, ApparentEnergy<T>.From, out quantity);
                case Type _ when quantityType == typeof(ApparentPower<T>):
                    return parser.TryParse<ApparentPower<T>, ApparentPowerUnit>(quantityString, formatProvider, ApparentPower<T>.From, out quantity);
                case Type _ when quantityType == typeof(Area<T>):
                    return parser.TryParse<Area<T>, AreaUnit>(quantityString, formatProvider, Area<T>.From, out quantity);
                case Type _ when quantityType == typeof(AreaDensity<T>):
                    return parser.TryParse<AreaDensity<T>, AreaDensityUnit>(quantityString, formatProvider, AreaDensity<T>.From, out quantity);
                case Type _ when quantityType == typeof(AreaMomentOfInertia<T>):
                    return parser.TryParse<AreaMomentOfInertia<T>, AreaMomentOfInertiaUnit>(quantityString, formatProvider, AreaMomentOfInertia<T>.From, out quantity);
                case Type _ when quantityType == typeof(BitRate<T>):
                    return parser.TryParse<BitRate<T>, BitRateUnit>(quantityString, formatProvider, BitRate<T>.From, out quantity);
                case Type _ when quantityType == typeof(BrakeSpecificFuelConsumption<T>):
                    return parser.TryParse<BrakeSpecificFuelConsumption<T>, BrakeSpecificFuelConsumptionUnit>(quantityString, formatProvider, BrakeSpecificFuelConsumption<T>.From, out quantity);
                case Type _ when quantityType == typeof(Capacitance<T>):
                    return parser.TryParse<Capacitance<T>, CapacitanceUnit>(quantityString, formatProvider, Capacitance<T>.From, out quantity);
                case Type _ when quantityType == typeof(CoefficientOfThermalExpansion<T>):
                    return parser.TryParse<CoefficientOfThermalExpansion<T>, CoefficientOfThermalExpansionUnit>(quantityString, formatProvider, CoefficientOfThermalExpansion<T>.From, out quantity);
                case Type _ when quantityType == typeof(Density<T>):
                    return parser.TryParse<Density<T>, DensityUnit>(quantityString, formatProvider, Density<T>.From, out quantity);
                case Type _ when quantityType == typeof(Duration<T>):
                    return parser.TryParse<Duration<T>, DurationUnit>(quantityString, formatProvider, Duration<T>.From, out quantity);
                case Type _ when quantityType == typeof(DynamicViscosity<T>):
                    return parser.TryParse<DynamicViscosity<T>, DynamicViscosityUnit>(quantityString, formatProvider, DynamicViscosity<T>.From, out quantity);
                case Type _ when quantityType == typeof(ElectricAdmittance<T>):
                    return parser.TryParse<ElectricAdmittance<T>, ElectricAdmittanceUnit>(quantityString, formatProvider, ElectricAdmittance<T>.From, out quantity);
                case Type _ when quantityType == typeof(ElectricCharge<T>):
                    return parser.TryParse<ElectricCharge<T>, ElectricChargeUnit>(quantityString, formatProvider, ElectricCharge<T>.From, out quantity);
                case Type _ when quantityType == typeof(ElectricChargeDensity<T>):
                    return parser.TryParse<ElectricChargeDensity<T>, ElectricChargeDensityUnit>(quantityString, formatProvider, ElectricChargeDensity<T>.From, out quantity);
                case Type _ when quantityType == typeof(ElectricConductance<T>):
                    return parser.TryParse<ElectricConductance<T>, ElectricConductanceUnit>(quantityString, formatProvider, ElectricConductance<T>.From, out quantity);
                case Type _ when quantityType == typeof(ElectricConductivity<T>):
                    return parser.TryParse<ElectricConductivity<T>, ElectricConductivityUnit>(quantityString, formatProvider, ElectricConductivity<T>.From, out quantity);
                case Type _ when quantityType == typeof(ElectricCurrent<T>):
                    return parser.TryParse<ElectricCurrent<T>, ElectricCurrentUnit>(quantityString, formatProvider, ElectricCurrent<T>.From, out quantity);
                case Type _ when quantityType == typeof(ElectricCurrentDensity<T>):
                    return parser.TryParse<ElectricCurrentDensity<T>, ElectricCurrentDensityUnit>(quantityString, formatProvider, ElectricCurrentDensity<T>.From, out quantity);
                case Type _ when quantityType == typeof(ElectricCurrentGradient<T>):
                    return parser.TryParse<ElectricCurrentGradient<T>, ElectricCurrentGradientUnit>(quantityString, formatProvider, ElectricCurrentGradient<T>.From, out quantity);
                case Type _ when quantityType == typeof(ElectricField<T>):
                    return parser.TryParse<ElectricField<T>, ElectricFieldUnit>(quantityString, formatProvider, ElectricField<T>.From, out quantity);
                case Type _ when quantityType == typeof(ElectricInductance<T>):
                    return parser.TryParse<ElectricInductance<T>, ElectricInductanceUnit>(quantityString, formatProvider, ElectricInductance<T>.From, out quantity);
                case Type _ when quantityType == typeof(ElectricPotential<T>):
                    return parser.TryParse<ElectricPotential<T>, ElectricPotentialUnit>(quantityString, formatProvider, ElectricPotential<T>.From, out quantity);
                case Type _ when quantityType == typeof(ElectricPotentialAc<T>):
                    return parser.TryParse<ElectricPotentialAc<T>, ElectricPotentialAcUnit>(quantityString, formatProvider, ElectricPotentialAc<T>.From, out quantity);
                case Type _ when quantityType == typeof(ElectricPotentialChangeRate<T>):
                    return parser.TryParse<ElectricPotentialChangeRate<T>, ElectricPotentialChangeRateUnit>(quantityString, formatProvider, ElectricPotentialChangeRate<T>.From, out quantity);
                case Type _ when quantityType == typeof(ElectricPotentialDc<T>):
                    return parser.TryParse<ElectricPotentialDc<T>, ElectricPotentialDcUnit>(quantityString, formatProvider, ElectricPotentialDc<T>.From, out quantity);
                case Type _ when quantityType == typeof(ElectricResistance<T>):
                    return parser.TryParse<ElectricResistance<T>, ElectricResistanceUnit>(quantityString, formatProvider, ElectricResistance<T>.From, out quantity);
                case Type _ when quantityType == typeof(ElectricResistivity<T>):
                    return parser.TryParse<ElectricResistivity<T>, ElectricResistivityUnit>(quantityString, formatProvider, ElectricResistivity<T>.From, out quantity);
                case Type _ when quantityType == typeof(ElectricSurfaceChargeDensity<T>):
                    return parser.TryParse<ElectricSurfaceChargeDensity<T>, ElectricSurfaceChargeDensityUnit>(quantityString, formatProvider, ElectricSurfaceChargeDensity<T>.From, out quantity);
                case Type _ when quantityType == typeof(Energy<T>):
                    return parser.TryParse<Energy<T>, EnergyUnit>(quantityString, formatProvider, Energy<T>.From, out quantity);
                case Type _ when quantityType == typeof(Entropy<T>):
                    return parser.TryParse<Entropy<T>, EntropyUnit>(quantityString, formatProvider, Entropy<T>.From, out quantity);
                case Type _ when quantityType == typeof(Force<T>):
                    return parser.TryParse<Force<T>, ForceUnit>(quantityString, formatProvider, Force<T>.From, out quantity);
                case Type _ when quantityType == typeof(ForceChangeRate<T>):
                    return parser.TryParse<ForceChangeRate<T>, ForceChangeRateUnit>(quantityString, formatProvider, ForceChangeRate<T>.From, out quantity);
                case Type _ when quantityType == typeof(ForcePerLength<T>):
                    return parser.TryParse<ForcePerLength<T>, ForcePerLengthUnit>(quantityString, formatProvider, ForcePerLength<T>.From, out quantity);
                case Type _ when quantityType == typeof(Frequency<T>):
                    return parser.TryParse<Frequency<T>, FrequencyUnit>(quantityString, formatProvider, Frequency<T>.From, out quantity);
                case Type _ when quantityType == typeof(FuelEfficiency<T>):
                    return parser.TryParse<FuelEfficiency<T>, FuelEfficiencyUnit>(quantityString, formatProvider, FuelEfficiency<T>.From, out quantity);
                case Type _ when quantityType == typeof(HeatFlux<T>):
                    return parser.TryParse<HeatFlux<T>, HeatFluxUnit>(quantityString, formatProvider, HeatFlux<T>.From, out quantity);
                case Type _ when quantityType == typeof(HeatTransferCoefficient<T>):
                    return parser.TryParse<HeatTransferCoefficient<T>, HeatTransferCoefficientUnit>(quantityString, formatProvider, HeatTransferCoefficient<T>.From, out quantity);
                case Type _ when quantityType == typeof(Illuminance<T>):
                    return parser.TryParse<Illuminance<T>, IlluminanceUnit>(quantityString, formatProvider, Illuminance<T>.From, out quantity);
                case Type _ when quantityType == typeof(Information<T>):
                    return parser.TryParse<Information<T>, InformationUnit>(quantityString, formatProvider, Information<T>.From, out quantity);
                case Type _ when quantityType == typeof(Irradiance<T>):
                    return parser.TryParse<Irradiance<T>, IrradianceUnit>(quantityString, formatProvider, Irradiance<T>.From, out quantity);
                case Type _ when quantityType == typeof(Irradiation<T>):
                    return parser.TryParse<Irradiation<T>, IrradiationUnit>(quantityString, formatProvider, Irradiation<T>.From, out quantity);
                case Type _ when quantityType == typeof(KinematicViscosity<T>):
                    return parser.TryParse<KinematicViscosity<T>, KinematicViscosityUnit>(quantityString, formatProvider, KinematicViscosity<T>.From, out quantity);
                case Type _ when quantityType == typeof(LapseRate<T>):
                    return parser.TryParse<LapseRate<T>, LapseRateUnit>(quantityString, formatProvider, LapseRate<T>.From, out quantity);
                case Type _ when quantityType == typeof(Length<T>):
                    return parser.TryParse<Length<T>, LengthUnit>(quantityString, formatProvider, Length<T>.From, out quantity);
                case Type _ when quantityType == typeof(Level<T>):
                    return parser.TryParse<Level<T>, LevelUnit>(quantityString, formatProvider, Level<T>.From, out quantity);
                case Type _ when quantityType == typeof(LinearDensity<T>):
                    return parser.TryParse<LinearDensity<T>, LinearDensityUnit>(quantityString, formatProvider, LinearDensity<T>.From, out quantity);
                case Type _ when quantityType == typeof(LinearPowerDensity<T>):
                    return parser.TryParse<LinearPowerDensity<T>, LinearPowerDensityUnit>(quantityString, formatProvider, LinearPowerDensity<T>.From, out quantity);
                case Type _ when quantityType == typeof(Luminosity<T>):
                    return parser.TryParse<Luminosity<T>, LuminosityUnit>(quantityString, formatProvider, Luminosity<T>.From, out quantity);
                case Type _ when quantityType == typeof(LuminousFlux<T>):
                    return parser.TryParse<LuminousFlux<T>, LuminousFluxUnit>(quantityString, formatProvider, LuminousFlux<T>.From, out quantity);
                case Type _ when quantityType == typeof(LuminousIntensity<T>):
                    return parser.TryParse<LuminousIntensity<T>, LuminousIntensityUnit>(quantityString, formatProvider, LuminousIntensity<T>.From, out quantity);
                case Type _ when quantityType == typeof(MagneticField<T>):
                    return parser.TryParse<MagneticField<T>, MagneticFieldUnit>(quantityString, formatProvider, MagneticField<T>.From, out quantity);
                case Type _ when quantityType == typeof(MagneticFlux<T>):
                    return parser.TryParse<MagneticFlux<T>, MagneticFluxUnit>(quantityString, formatProvider, MagneticFlux<T>.From, out quantity);
                case Type _ when quantityType == typeof(Magnetization<T>):
                    return parser.TryParse<Magnetization<T>, MagnetizationUnit>(quantityString, formatProvider, Magnetization<T>.From, out quantity);
                case Type _ when quantityType == typeof(Mass<T>):
                    return parser.TryParse<Mass<T>, MassUnit>(quantityString, formatProvider, Mass<T>.From, out quantity);
                case Type _ when quantityType == typeof(MassConcentration<T>):
                    return parser.TryParse<MassConcentration<T>, MassConcentrationUnit>(quantityString, formatProvider, MassConcentration<T>.From, out quantity);
                case Type _ when quantityType == typeof(MassFlow<T>):
                    return parser.TryParse<MassFlow<T>, MassFlowUnit>(quantityString, formatProvider, MassFlow<T>.From, out quantity);
                case Type _ when quantityType == typeof(MassFlux<T>):
                    return parser.TryParse<MassFlux<T>, MassFluxUnit>(quantityString, formatProvider, MassFlux<T>.From, out quantity);
                case Type _ when quantityType == typeof(MassFraction<T>):
                    return parser.TryParse<MassFraction<T>, MassFractionUnit>(quantityString, formatProvider, MassFraction<T>.From, out quantity);
                case Type _ when quantityType == typeof(MassMomentOfInertia<T>):
                    return parser.TryParse<MassMomentOfInertia<T>, MassMomentOfInertiaUnit>(quantityString, formatProvider, MassMomentOfInertia<T>.From, out quantity);
                case Type _ when quantityType == typeof(MolarEnergy<T>):
                    return parser.TryParse<MolarEnergy<T>, MolarEnergyUnit>(quantityString, formatProvider, MolarEnergy<T>.From, out quantity);
                case Type _ when quantityType == typeof(MolarEntropy<T>):
                    return parser.TryParse<MolarEntropy<T>, MolarEntropyUnit>(quantityString, formatProvider, MolarEntropy<T>.From, out quantity);
                case Type _ when quantityType == typeof(Molarity<T>):
                    return parser.TryParse<Molarity<T>, MolarityUnit>(quantityString, formatProvider, Molarity<T>.From, out quantity);
                case Type _ when quantityType == typeof(MolarMass<T>):
                    return parser.TryParse<MolarMass<T>, MolarMassUnit>(quantityString, formatProvider, MolarMass<T>.From, out quantity);
                case Type _ when quantityType == typeof(Permeability<T>):
                    return parser.TryParse<Permeability<T>, PermeabilityUnit>(quantityString, formatProvider, Permeability<T>.From, out quantity);
                case Type _ when quantityType == typeof(Permittivity<T>):
                    return parser.TryParse<Permittivity<T>, PermittivityUnit>(quantityString, formatProvider, Permittivity<T>.From, out quantity);
                case Type _ when quantityType == typeof(Power<T>):
                    return parser.TryParse<Power<T>, PowerUnit>(quantityString, formatProvider, Power<T>.From, out quantity);
                case Type _ when quantityType == typeof(PowerDensity<T>):
                    return parser.TryParse<PowerDensity<T>, PowerDensityUnit>(quantityString, formatProvider, PowerDensity<T>.From, out quantity);
                case Type _ when quantityType == typeof(PowerRatio<T>):
                    return parser.TryParse<PowerRatio<T>, PowerRatioUnit>(quantityString, formatProvider, PowerRatio<T>.From, out quantity);
                case Type _ when quantityType == typeof(Pressure<T>):
                    return parser.TryParse<Pressure<T>, PressureUnit>(quantityString, formatProvider, Pressure<T>.From, out quantity);
                case Type _ when quantityType == typeof(PressureChangeRate<T>):
                    return parser.TryParse<PressureChangeRate<T>, PressureChangeRateUnit>(quantityString, formatProvider, PressureChangeRate<T>.From, out quantity);
                case Type _ when quantityType == typeof(Ratio<T>):
                    return parser.TryParse<Ratio<T>, RatioUnit>(quantityString, formatProvider, Ratio<T>.From, out quantity);
                case Type _ when quantityType == typeof(RatioChangeRate<T>):
                    return parser.TryParse<RatioChangeRate<T>, RatioChangeRateUnit>(quantityString, formatProvider, RatioChangeRate<T>.From, out quantity);
                case Type _ when quantityType == typeof(ReactiveEnergy<T>):
                    return parser.TryParse<ReactiveEnergy<T>, ReactiveEnergyUnit>(quantityString, formatProvider, ReactiveEnergy<T>.From, out quantity);
                case Type _ when quantityType == typeof(ReactivePower<T>):
                    return parser.TryParse<ReactivePower<T>, ReactivePowerUnit>(quantityString, formatProvider, ReactivePower<T>.From, out quantity);
                case Type _ when quantityType == typeof(RelativeHumidity<T>):
                    return parser.TryParse<RelativeHumidity<T>, RelativeHumidityUnit>(quantityString, formatProvider, RelativeHumidity<T>.From, out quantity);
                case Type _ when quantityType == typeof(RotationalAcceleration<T>):
                    return parser.TryParse<RotationalAcceleration<T>, RotationalAccelerationUnit>(quantityString, formatProvider, RotationalAcceleration<T>.From, out quantity);
                case Type _ when quantityType == typeof(RotationalSpeed<T>):
                    return parser.TryParse<RotationalSpeed<T>, RotationalSpeedUnit>(quantityString, formatProvider, RotationalSpeed<T>.From, out quantity);
                case Type _ when quantityType == typeof(RotationalStiffness<T>):
                    return parser.TryParse<RotationalStiffness<T>, RotationalStiffnessUnit>(quantityString, formatProvider, RotationalStiffness<T>.From, out quantity);
                case Type _ when quantityType == typeof(RotationalStiffnessPerLength<T>):
                    return parser.TryParse<RotationalStiffnessPerLength<T>, RotationalStiffnessPerLengthUnit>(quantityString, formatProvider, RotationalStiffnessPerLength<T>.From, out quantity);
                case Type _ when quantityType == typeof(SolidAngle<T>):
                    return parser.TryParse<SolidAngle<T>, SolidAngleUnit>(quantityString, formatProvider, SolidAngle<T>.From, out quantity);
                case Type _ when quantityType == typeof(SpecificEnergy<T>):
                    return parser.TryParse<SpecificEnergy<T>, SpecificEnergyUnit>(quantityString, formatProvider, SpecificEnergy<T>.From, out quantity);
                case Type _ when quantityType == typeof(SpecificEntropy<T>):
                    return parser.TryParse<SpecificEntropy<T>, SpecificEntropyUnit>(quantityString, formatProvider, SpecificEntropy<T>.From, out quantity);
                case Type _ when quantityType == typeof(SpecificVolume<T>):
                    return parser.TryParse<SpecificVolume<T>, SpecificVolumeUnit>(quantityString, formatProvider, SpecificVolume<T>.From, out quantity);
                case Type _ when quantityType == typeof(SpecificWeight<T>):
                    return parser.TryParse<SpecificWeight<T>, SpecificWeightUnit>(quantityString, formatProvider, SpecificWeight<T>.From, out quantity);
                case Type _ when quantityType == typeof(Speed<T>):
                    return parser.TryParse<Speed<T>, SpeedUnit>(quantityString, formatProvider, Speed<T>.From, out quantity);
                case Type _ when quantityType == typeof(Temperature<T>):
                    return parser.TryParse<Temperature<T>, TemperatureUnit>(quantityString, formatProvider, Temperature<T>.From, out quantity);
                case Type _ when quantityType == typeof(TemperatureChangeRate<T>):
                    return parser.TryParse<TemperatureChangeRate<T>, TemperatureChangeRateUnit>(quantityString, formatProvider, TemperatureChangeRate<T>.From, out quantity);
                case Type _ when quantityType == typeof(TemperatureDelta<T>):
                    return parser.TryParse<TemperatureDelta<T>, TemperatureDeltaUnit>(quantityString, formatProvider, TemperatureDelta<T>.From, out quantity);
                case Type _ when quantityType == typeof(ThermalConductivity<T>):
                    return parser.TryParse<ThermalConductivity<T>, ThermalConductivityUnit>(quantityString, formatProvider, ThermalConductivity<T>.From, out quantity);
                case Type _ when quantityType == typeof(ThermalResistance<T>):
                    return parser.TryParse<ThermalResistance<T>, ThermalResistanceUnit>(quantityString, formatProvider, ThermalResistance<T>.From, out quantity);
                case Type _ when quantityType == typeof(Torque<T>):
                    return parser.TryParse<Torque<T>, TorqueUnit>(quantityString, formatProvider, Torque<T>.From, out quantity);
                case Type _ when quantityType == typeof(TorquePerLength<T>):
                    return parser.TryParse<TorquePerLength<T>, TorquePerLengthUnit>(quantityString, formatProvider, TorquePerLength<T>.From, out quantity);
                case Type _ when quantityType == typeof(Turbidity<T>):
                    return parser.TryParse<Turbidity<T>, TurbidityUnit>(quantityString, formatProvider, Turbidity<T>.From, out quantity);
                case Type _ when quantityType == typeof(VitaminA<T>):
                    return parser.TryParse<VitaminA<T>, VitaminAUnit>(quantityString, formatProvider, VitaminA<T>.From, out quantity);
                case Type _ when quantityType == typeof(Volume<T>):
                    return parser.TryParse<Volume<T>, VolumeUnit>(quantityString, formatProvider, Volume<T>.From, out quantity);
                case Type _ when quantityType == typeof(VolumeConcentration<T>):
                    return parser.TryParse<VolumeConcentration<T>, VolumeConcentrationUnit>(quantityString, formatProvider, VolumeConcentration<T>.From, out quantity);
                case Type _ when quantityType == typeof(VolumeFlow<T>):
                    return parser.TryParse<VolumeFlow<T>, VolumeFlowUnit>(quantityString, formatProvider, VolumeFlow<T>.From, out quantity);
                case Type _ when quantityType == typeof(VolumePerLength<T>):
                    return parser.TryParse<VolumePerLength<T>, VolumePerLengthUnit>(quantityString, formatProvider, VolumePerLength<T>.From, out quantity);
                case Type _ when quantityType == typeof(WarpingMomentOfInertia<T>):
                    return parser.TryParse<WarpingMomentOfInertia<T>, WarpingMomentOfInertiaUnit>(quantityString, formatProvider, WarpingMomentOfInertia<T>.From, out quantity);
                default:
                    return false;
            }
        }
    }
}
